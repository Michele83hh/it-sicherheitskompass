---
phase: 02-nis2-content-scoring-engine
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/lib/scoring/types.ts
  - src/lib/scoring/engine.ts
  - src/lib/scoring/engine.test.ts
  - src/lib/scoring/methodology.ts
  - vitest.config.ts
  - package.json
autonomous: true
must_haves:
  truths:
    - "vitest is installed and configured"
    - "Pure scoring functions calculate per-category percentage from maturity level answers"
    - "Traffic light function returns 'red' (<40%), 'yellow' (40-69%), 'green' (>=70%)"
    - "Overall readiness score averages all 10 category scores with equal weighting"
    - "All scoring functions are pure (no side effects, no React dependencies)"
    - "Unit tests pass with vitest covering boundary values, empty arrays, mixed levels, category filtering"
    - "Scoring methodology is documented as structured data for transparency (SCORE-07)"
    - "TypeScript compiles with zero errors"
  artifacts:
    - path: "src/lib/scoring/types.ts"
      provides: "Scoring types: re-exported from nis2/types.ts plus QuestionCatalogEntry for engine input"
    - path: "src/lib/scoring/engine.ts"
      provides: "Pure scoring functions: calculateCategoryScore, calculateOverallScore, getTrafficLight, maturityLevelToPercentage, roundToOneDecimal"
    - path: "src/lib/scoring/engine.test.ts"
      provides: "Comprehensive vitest unit tests for all scoring functions"
    - path: "src/lib/scoring/methodology.ts"
      provides: "Scoring methodology explanation as structured data for UI display"
    - path: "vitest.config.ts"
      provides: "Vitest configuration with path aliases matching tsconfig"
---

<objective>
Create the NIS2 scoring engine: pure TypeScript functions for calculating readiness scores from maturity level answers, with comprehensive vitest unit tests and methodology documentation.

Purpose: The scoring engine is the calculation core of the tool. It converts user answers (maturity levels 0-3) into per-category percentages, traffic light colors, and an overall readiness score. Pure functions with full test coverage ensure correctness and allow confident refactoring.
Output: Scoring types, engine functions, methodology data, vitest config, and 20+ unit tests all passing.
</objective>

<execution_context>
@C:\Users\mjoan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\mjoan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:\Users\mjoan\Desktop\nis2-readiness-check\.planning\PROJECT.md
@C:\Users\mjoan\Desktop\nis2-readiness-check\.planning\ROADMAP.md
@C:\Users\mjoan\Desktop\nis2-readiness-check\.planning\STATE.md
@C:\Users\mjoan\Desktop\nis2-readiness-check\.planning\phases\02-nis2-content-scoring-engine\02-RESEARCH.md

# Types from 02-01 are critical — the scoring engine depends on them:
@C:\Users\mjoan\Desktop\nis2-readiness-check\src\lib\nis2\types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install vitest and create configuration</name>
  <files>
    package.json
    vitest.config.ts
  </files>
  <action>
    1. Install vitest as a dev dependency:

       ```bash
       npm install --save-dev vitest
       ```

    2. Add a "test" script to package.json scripts section. The scripts section should look like this after the change:

       ```json
       "scripts": {
         "dev": "next dev",
         "build": "next build",
         "start": "next start",
         "lint": "eslint",
         "test": "vitest run",
         "test:watch": "vitest"
       }
       ```

       Only ADD the "test" and "test:watch" entries. Do NOT modify existing scripts.

    3. Create `vitest.config.ts` in the project root with the following exact content:

       ```typescript
       // vitest.config.ts

       import { defineConfig } from 'vitest/config';
       import path from 'path';

       export default defineConfig({
         test: {
           globals: true,
           environment: 'node', // Pure functions — no DOM needed
           include: ['src/**/*.test.ts'],
           coverage: {
             provider: 'v8',
             reporter: ['text', 'json', 'html'],
             include: ['src/lib/scoring/**/*.ts'],
             exclude: ['**/*.test.ts', '**/*.d.ts'],
           },
         },
         resolve: {
           alias: {
             '@': path.resolve(__dirname, './src'),
           },
         },
       });
       ```

       NOTE: The `@/` alias must match the tsconfig.json `paths` configuration exactly: `"@/*": ["./src/*"]`.
  </action>
  <verify>
    - `npx vitest --version` outputs a version number (confirming installation)
    - `vitest.config.ts` exists in project root
    - `package.json` contains "test" and "test:watch" scripts
    - `npx tsc --noEmit` returns zero errors (vitest config compiles)
  </verify>
  <done>
    vitest installed as devDependency, vitest.config.ts created with correct path aliases, test scripts added to package.json.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create scoring types, engine, and methodology</name>
  <files>
    src/lib/scoring/types.ts
    src/lib/scoring/engine.ts
    src/lib/scoring/methodology.ts
  </files>
  <action>
    1. Create the directory `src/lib/scoring/` if it does not exist.

    2. Create `src/lib/scoring/types.ts` with the following exact content. This file re-exports scoring types from the shared NIS2 types and adds an engine-specific helper type:

       ```typescript
       // src/lib/scoring/types.ts

       /**
        * Scoring Engine Types
        *
        * Re-exports scoring-related types from the shared NIS2 types module,
        * plus engine-specific types for the scoring calculation.
        */

       // Re-export scoring types from the shared NIS2 types
       export type {
         MaturityLevel,
         TrafficLight,
         Answer,
         CategoryScore,
         OverallScore,
       } from '@/lib/nis2/types';

       /**
        * Minimal category info needed by the scoring engine.
        * Maps category IDs to their total question count.
        * This avoids coupling the engine to the full Category/Question types.
        */
       export interface CategoryQuestionCount {
         categoryId: string;
         totalQuestions: number;
       }
       ```

    3. Create `src/lib/scoring/engine.ts` with the following exact content. ALL functions must be pure (no side effects, no imports from React, no global state):

       ```typescript
       // src/lib/scoring/engine.ts

       /**
        * NIS2 Readiness Scoring Engine
        *
        * Pure functions for calculating NIS2 readiness scores from maturity level answers.
        * No side effects, no React dependencies, no global state.
        *
        * Scoring methodology:
        * - MaturityLevel 0 = 0%, 1 = 33.3%, 2 = 66.7%, 3 = 100%
        * - Category score = average percentage of answered questions in that category
        * - Traffic light: <40% = red, 40-69% = yellow, >=70% = green
        * - Overall score = average of all category scores (equal weighting)
        *
        * Legal context: Measures per Art. 21(2)(a-j) EU NIS2 / §30 Abs. 2 Nr. 1-10 BSIG
        */

       import type { MaturityLevel, TrafficLight, Answer, CategoryScore, OverallScore, CategoryQuestionCount } from './types';

       /**
        * Converts a maturity level (0-3) to a percentage (0-100).
        *
        * Formula: (level / 3) * 100
        * - Level 0: 0%
        * - Level 1: 33.3%
        * - Level 2: 66.7%
        * - Level 3: 100%
        *
        * Uses division instead of multiplication by 33.33 to avoid floating-point
        * accumulation errors (e.g., 3 * 33.33 = 99.99 instead of 100).
        */
       export function maturityLevelToPercentage(level: MaturityLevel): number {
         return (level / 3) * 100;
       }

       /**
        * Rounds a number to 1 decimal place.
        *
        * Uses the multiply-round-divide pattern to avoid floating-point display issues.
        * Example: 66.666... → 66.7, 33.333... → 33.3
        */
       export function roundToOneDecimal(value: number): number {
         return Math.round(value * 10) / 10;
       }

       /**
        * Determines traffic light color based on percentage score.
        *
        * Thresholds (industry-standard RAG for maturity assessment):
        * - Red:    <40%  — Significant gaps, immediate action required
        * - Yellow: 40-69% — Partial implementation, improvements needed
        * - Green:  >=70% — Mature implementation, maintain and optimize
        *
        * IMPORTANT: A green score does NOT mean NIS2 compliance.
        * Every measure must be "suitable, proportionate, and effective"
        * per §30 Abs. 1 BSIG for the organization's specific risk profile.
        *
        * @param percentage - Score percentage (0-100)
        * @returns Traffic light color
        */
       export function getTrafficLight(percentage: number): TrafficLight {
         if (percentage < 40) return 'red';
         if (percentage < 70) return 'yellow';
         return 'green';
       }

       /**
        * Calculates the maturity score for a single NIS2 category.
        *
        * Steps:
        * 1. Filter answers by categoryId
        * 2. Convert each answer's MaturityLevel to percentage via (level / 3) * 100
        * 3. Average the percentages across all answered questions
        * 4. Round to 1 decimal place
        * 5. Apply traffic light threshold
        *
        * Edge cases:
        * - Empty answers or no answers for this category → 0% with red traffic light
        * - Partial completion → score based only on answered questions
        *
        * @param answers - All user answers (will be filtered by categoryId)
        * @param categoryId - Target category ID to score
        * @param totalQuestions - Total questions in this category (for metadata)
        * @returns CategoryScore with percentage, traffic light, and completion counts
        */
       export function calculateCategoryScore(
         answers: Answer[],
         categoryId: string,
         totalQuestions: number
       ): CategoryScore {
         const categoryAnswers = answers.filter((a) => a.categoryId === categoryId);

         if (categoryAnswers.length === 0) {
           return {
             categoryId,
             percentage: 0,
             trafficLight: 'red',
             answeredQuestions: 0,
             totalQuestions,
           };
         }

         const percentageSum = categoryAnswers.reduce((sum, answer) => {
           return sum + maturityLevelToPercentage(answer.level);
         }, 0);

         const averagePercentage = percentageSum / categoryAnswers.length;
         const rounded = roundToOneDecimal(averagePercentage);

         return {
           categoryId,
           percentage: rounded,
           trafficLight: getTrafficLight(rounded),
           answeredQuestions: categoryAnswers.length,
           totalQuestions,
         };
       }

       /**
        * Calculates the overall NIS2 readiness score across all categories.
        *
        * Steps:
        * 1. Calculate score for each category
        * 2. Average all category percentages (equal weighting)
        * 3. Sum up answered/total questions for completion rate
        * 4. Round overall percentage to 1 decimal place
        *
        * Equal weighting rationale: All 10 NIS2 Art. 21(2) measures are equally
        * mandatory. No legal basis exists for weighting one measure above another.
        *
        * Edge cases:
        * - No categories → 0% with red traffic light, 0% completion
        * - All categories scored → full calculation
        *
        * @param answers - All user answers across all categories
        * @param categories - Array of category IDs with their total question counts
        * @returns OverallScore with percentage, category scores, and completion rate
        */
       export function calculateOverallScore(
         answers: Answer[],
         categories: CategoryQuestionCount[]
       ): OverallScore {
         if (categories.length === 0) {
           return {
             percentage: 0,
             trafficLight: 'red',
             categoryScores: [],
             answeredQuestions: 0,
             totalQuestions: 0,
             completionRate: 0,
           };
         }

         const categoryScores = categories.map((cat) =>
           calculateCategoryScore(answers, cat.categoryId, cat.totalQuestions)
         );

         const overallPercentageSum = categoryScores.reduce(
           (sum, cs) => sum + cs.percentage,
           0
         );
         const overallPercentage = roundToOneDecimal(
           overallPercentageSum / categoryScores.length
         );

         const totalAnswered = categoryScores.reduce(
           (sum, cs) => sum + cs.answeredQuestions,
           0
         );
         const totalQuestions = categoryScores.reduce(
           (sum, cs) => sum + cs.totalQuestions,
           0
         );

         const completionRate =
           totalQuestions > 0
             ? roundToOneDecimal((totalAnswered / totalQuestions) * 100)
             : 0;

         return {
           percentage: overallPercentage,
           trafficLight: getTrafficLight(overallPercentage),
           categoryScores,
           answeredQuestions: totalAnswered,
           totalQuestions,
           completionRate,
         };
       }
       ```

    4. Create `src/lib/scoring/methodology.ts` with the following exact content. This provides structured data for the UI to explain how scores are calculated (SCORE-07 requirement: transparency):

       ```typescript
       // src/lib/scoring/methodology.ts

       /**
        * Scoring Methodology Documentation
        *
        * Structured data explaining how NIS2 readiness scores are calculated.
        * Used by the Results Dashboard UI to show methodology transparency (SCORE-07).
        * All text uses translation keys for i18n support.
        */

       export interface MethodologyStep {
         id: string;
         titleKey: string;
         descriptionKey: string;
       }

       export interface TrafficLightExplanation {
         color: 'red' | 'yellow' | 'green';
         labelKey: string;
         rangeKey: string;
         descriptionKey: string;
       }

       export interface ScoringMethodology {
         titleKey: string;
         introKey: string;
         steps: MethodologyStep[];
         trafficLights: TrafficLightExplanation[];
         disclaimerKey: string;
         legalBasis: string;
       }

       /**
        * Complete scoring methodology as structured data.
        *
        * The UI reads this object and resolves translation keys at render time
        * via next-intl's `useTranslations()` hook.
        */
       export const SCORING_METHODOLOGY: ScoringMethodology = {
         titleKey: 'methodology.title',
         introKey: 'methodology.intro',
         steps: [
           {
             id: 'maturity-levels',
             titleKey: 'methodology.steps.maturityLevels.title',
             descriptionKey: 'methodology.steps.maturityLevels.description',
           },
           {
             id: 'category-score',
             titleKey: 'methodology.steps.categoryScore.title',
             descriptionKey: 'methodology.steps.categoryScore.description',
           },
           {
             id: 'traffic-light',
             titleKey: 'methodology.steps.trafficLight.title',
             descriptionKey: 'methodology.steps.trafficLight.description',
           },
           {
             id: 'overall-score',
             titleKey: 'methodology.steps.overallScore.title',
             descriptionKey: 'methodology.steps.overallScore.description',
           },
         ],
         trafficLights: [
           {
             color: 'red',
             labelKey: 'methodology.trafficLights.red.label',
             rangeKey: 'methodology.trafficLights.red.range',
             descriptionKey: 'methodology.trafficLights.red.description',
           },
           {
             color: 'yellow',
             labelKey: 'methodology.trafficLights.yellow.label',
             rangeKey: 'methodology.trafficLights.yellow.range',
             descriptionKey: 'methodology.trafficLights.yellow.description',
           },
           {
             color: 'green',
             labelKey: 'methodology.trafficLights.green.label',
             rangeKey: 'methodology.trafficLights.green.range',
             descriptionKey: 'methodology.trafficLights.green.description',
           },
         ],
         disclaimerKey: 'methodology.disclaimer',
         legalBasis: 'Art. 21(2)(a-j) NIS2-RL / §30 Abs. 2 Nr. 1-10 BSIG (BGBl. 2025 I Nr. 301)',
       };
       ```

  </action>
  <verify>
    - `src/lib/scoring/types.ts` exists and re-exports scoring types from `@/lib/nis2/types`
    - `src/lib/scoring/engine.ts` exists and exports: maturityLevelToPercentage, roundToOneDecimal, getTrafficLight, calculateCategoryScore, calculateOverallScore
    - `src/lib/scoring/methodology.ts` exists and exports SCORING_METHODOLOGY
    - All functions in engine.ts are pure (no imports from React, no fetch, no global state mutation)
    - `npx tsc --noEmit` returns zero errors
  </verify>
  <done>
    Scoring types re-exported for clean imports. Five pure scoring functions implemented with correct formulas. Methodology data structured for UI transparency. Zero TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive unit tests and verify all pass</name>
  <files>
    src/lib/scoring/engine.test.ts
  </files>
  <action>
    1. Create `src/lib/scoring/engine.test.ts` with the following exact content. This is the comprehensive test suite covering all scoring functions with boundary values, edge cases, and realistic scenarios:

       ```typescript
       // src/lib/scoring/engine.test.ts

       import { describe, it, expect } from 'vitest';
       import {
         maturityLevelToPercentage,
         roundToOneDecimal,
         getTrafficLight,
         calculateCategoryScore,
         calculateOverallScore,
       } from './engine';
       import type { Answer, CategoryQuestionCount } from './types';

       // ============================================================
       // Helper: Create an Answer object for a given category
       // ============================================================

       function createAnswer(
         questionId: string,
         categoryId: string,
         level: 0 | 1 | 2 | 3
       ): Answer {
         return { questionId, categoryId, level };
       }

       // ============================================================
       // maturityLevelToPercentage
       // ============================================================

       describe('maturityLevelToPercentage', () => {
         it('converts level 0 to 0%', () => {
           expect(maturityLevelToPercentage(0)).toBe(0);
         });

         it('converts level 1 to ~33.3%', () => {
           expect(maturityLevelToPercentage(1)).toBeCloseTo(33.333, 2);
         });

         it('converts level 2 to ~66.7%', () => {
           expect(maturityLevelToPercentage(2)).toBeCloseTo(66.667, 2);
         });

         it('converts level 3 to exactly 100%', () => {
           expect(maturityLevelToPercentage(3)).toBe(100);
         });
       });

       // ============================================================
       // roundToOneDecimal
       // ============================================================

       describe('roundToOneDecimal', () => {
         it('rounds 33.333... to 33.3', () => {
           expect(roundToOneDecimal(33.33333)).toBe(33.3);
         });

         it('rounds 66.666... to 66.7', () => {
           expect(roundToOneDecimal(66.66667)).toBe(66.7);
         });

         it('keeps exact integers unchanged', () => {
           expect(roundToOneDecimal(50)).toBe(50);
           expect(roundToOneDecimal(0)).toBe(0);
           expect(roundToOneDecimal(100)).toBe(100);
         });

         it('rounds 99.95 to 100.0', () => {
           expect(roundToOneDecimal(99.95)).toBe(100);
         });

         it('rounds 39.94 to 39.9', () => {
           expect(roundToOneDecimal(39.94)).toBe(39.9);
         });

         it('rounds 39.95 to 40.0', () => {
           expect(roundToOneDecimal(39.95)).toBe(40);
         });
       });

       // ============================================================
       // getTrafficLight
       // ============================================================

       describe('getTrafficLight', () => {
         it('returns red for 0%', () => {
           expect(getTrafficLight(0)).toBe('red');
         });

         it('returns red for scores below 40%', () => {
           expect(getTrafficLight(10)).toBe('red');
           expect(getTrafficLight(25)).toBe('red');
           expect(getTrafficLight(39)).toBe('red');
           expect(getTrafficLight(39.9)).toBe('red');
         });

         it('returns yellow for exactly 40%', () => {
           expect(getTrafficLight(40)).toBe('yellow');
         });

         it('returns yellow for scores between 40% and 69%', () => {
           expect(getTrafficLight(40.1)).toBe('yellow');
           expect(getTrafficLight(50)).toBe('yellow');
           expect(getTrafficLight(55)).toBe('yellow');
           expect(getTrafficLight(69)).toBe('yellow');
           expect(getTrafficLight(69.9)).toBe('yellow');
         });

         it('returns green for exactly 70%', () => {
           expect(getTrafficLight(70)).toBe('green');
         });

         it('returns green for scores above 70%', () => {
           expect(getTrafficLight(70.1)).toBe('green');
           expect(getTrafficLight(85)).toBe('green');
           expect(getTrafficLight(100)).toBe('green');
         });

         it('handles boundary 39.9 as red (not yellow)', () => {
           expect(getTrafficLight(39.9)).toBe('red');
         });

         it('handles boundary 69.9 as yellow (not green)', () => {
           expect(getTrafficLight(69.9)).toBe('yellow');
         });
       });

       // ============================================================
       // calculateCategoryScore
       // ============================================================

       describe('calculateCategoryScore', () => {
         const CATEGORY_ID = 'risk-analysis';

         it('returns 0% with red for empty answers array', () => {
           const result = calculateCategoryScore([], CATEGORY_ID, 3);

           expect(result.categoryId).toBe(CATEGORY_ID);
           expect(result.percentage).toBe(0);
           expect(result.trafficLight).toBe('red');
           expect(result.answeredQuestions).toBe(0);
           expect(result.totalQuestions).toBe(3);
         });

         it('returns 0% with red for no matching category answers', () => {
           const answers = [
             createAnswer('q1', 'other-category', 3),
             createAnswer('q2', 'other-category', 3),
           ];

           const result = calculateCategoryScore(answers, CATEGORY_ID, 3);

           expect(result.percentage).toBe(0);
           expect(result.trafficLight).toBe('red');
           expect(result.answeredQuestions).toBe(0);
         });

         it('calculates 0% for all level-0 answers', () => {
           const answers = [
             createAnswer('q1', CATEGORY_ID, 0),
             createAnswer('q2', CATEGORY_ID, 0),
             createAnswer('q3', CATEGORY_ID, 0),
           ];

           const result = calculateCategoryScore(answers, CATEGORY_ID, 3);

           expect(result.percentage).toBe(0);
           expect(result.trafficLight).toBe('red');
           expect(result.answeredQuestions).toBe(3);
         });

         it('calculates 100% for all level-3 answers', () => {
           const answers = [
             createAnswer('q1', CATEGORY_ID, 3),
             createAnswer('q2', CATEGORY_ID, 3),
             createAnswer('q3', CATEGORY_ID, 3),
           ];

           const result = calculateCategoryScore(answers, CATEGORY_ID, 3);

           expect(result.percentage).toBe(100);
           expect(result.trafficLight).toBe('green');
           expect(result.answeredQuestions).toBe(3);
         });

         it('calculates ~33.3% for all level-1 answers', () => {
           const answers = [
             createAnswer('q1', CATEGORY_ID, 1),
             createAnswer('q2', CATEGORY_ID, 1),
             createAnswer('q3', CATEGORY_ID, 1),
           ];

           const result = calculateCategoryScore(answers, CATEGORY_ID, 3);

           expect(result.percentage).toBe(33.3);
           expect(result.trafficLight).toBe('red');
         });

         it('calculates ~66.7% for all level-2 answers', () => {
           const answers = [
             createAnswer('q1', CATEGORY_ID, 2),
             createAnswer('q2', CATEGORY_ID, 2),
             createAnswer('q3', CATEGORY_ID, 2),
           ];

           const result = calculateCategoryScore(answers, CATEGORY_ID, 3);

           expect(result.percentage).toBe(66.7);
           expect(result.trafficLight).toBe('yellow');
         });

         it('calculates 50% for mixed levels [0, 1, 2, 3]', () => {
           const answers = [
             createAnswer('q1', CATEGORY_ID, 0), // 0%
             createAnswer('q2', CATEGORY_ID, 1), // 33.33%
             createAnswer('q3', CATEGORY_ID, 2), // 66.67%
             createAnswer('q4', CATEGORY_ID, 3), // 100%
           ];
           // Average: (0 + 33.33 + 66.67 + 100) / 4 = 50%

           const result = calculateCategoryScore(answers, CATEGORY_ID, 4);

           expect(result.percentage).toBe(50);
           expect(result.trafficLight).toBe('yellow');
           expect(result.answeredQuestions).toBe(4);
           expect(result.totalQuestions).toBe(4);
         });

         it('filters answers by categoryId — ignores other categories', () => {
           const answers = [
             createAnswer('q1', CATEGORY_ID, 3),         // 100% — counted
             createAnswer('q2', 'incident-response', 0),  // different category — ignored
             createAnswer('q3', CATEGORY_ID, 3),         // 100% — counted
             createAnswer('q4', 'supply-chain', 1),       // different category — ignored
           ];

           const result = calculateCategoryScore(answers, CATEGORY_ID, 4);

           expect(result.answeredQuestions).toBe(2);
           expect(result.percentage).toBe(100);
           expect(result.trafficLight).toBe('green');
         });

         it('handles partial completion (some questions unanswered)', () => {
           const answers = [
             createAnswer('q1', CATEGORY_ID, 2), // 66.67%
             createAnswer('q2', CATEGORY_ID, 2), // 66.67%
             // q3 not answered
           ];

           const result = calculateCategoryScore(answers, CATEGORY_ID, 3);

           expect(result.answeredQuestions).toBe(2);
           expect(result.totalQuestions).toBe(3);
           expect(result.percentage).toBe(66.7);
           expect(result.trafficLight).toBe('yellow');
         });

         it('handles single answer correctly', () => {
           const answers = [createAnswer('q1', CATEGORY_ID, 2)]; // 66.67%

           const result = calculateCategoryScore(answers, CATEGORY_ID, 4);

           expect(result.answeredQuestions).toBe(1);
           expect(result.totalQuestions).toBe(4);
           expect(result.percentage).toBe(66.7);
         });

         it('rounds to 1 decimal place for display', () => {
           // Level 1 = 33.333...% — must display as 33.3
           const answers = [createAnswer('q1', CATEGORY_ID, 1)];

           const result = calculateCategoryScore(answers, CATEGORY_ID, 1);

           expect(result.percentage).toBe(33.3);
         });

         it('avoids floating-point accumulation error with level 3', () => {
           // Using (level / 3) * 100 for level 3 should give exactly 100, not 99.99
           const answers = [
             createAnswer('q1', CATEGORY_ID, 3),
             createAnswer('q2', CATEGORY_ID, 3),
             createAnswer('q3', CATEGORY_ID, 3),
           ];

           const result = calculateCategoryScore(answers, CATEGORY_ID, 3);

           expect(result.percentage).toBe(100); // NOT 99.9
         });
       });

       // ============================================================
       // calculateOverallScore
       // ============================================================

       describe('calculateOverallScore', () => {
         it('returns zeros for empty categories array', () => {
           const result = calculateOverallScore([], []);

           expect(result.percentage).toBe(0);
           expect(result.trafficLight).toBe('red');
           expect(result.categoryScores).toHaveLength(0);
           expect(result.answeredQuestions).toBe(0);
           expect(result.totalQuestions).toBe(0);
           expect(result.completionRate).toBe(0);
         });

         it('calculates overall score as average of category scores', () => {
           const categories: CategoryQuestionCount[] = [
             { categoryId: 'cat1', totalQuestions: 3 },
             { categoryId: 'cat2', totalQuestions: 3 },
           ];

           const answers: Answer[] = [
             // cat1: all level 3 → 100%
             createAnswer('q1', 'cat1', 3),
             createAnswer('q2', 'cat1', 3),
             createAnswer('q3', 'cat1', 3),
             // cat2: all level 0 → 0%
             createAnswer('q4', 'cat2', 0),
             createAnswer('q5', 'cat2', 0),
             createAnswer('q6', 'cat2', 0),
           ];
           // Overall: (100 + 0) / 2 = 50%

           const result = calculateOverallScore(answers, categories);

           expect(result.percentage).toBe(50);
           expect(result.trafficLight).toBe('yellow');
           expect(result.categoryScores).toHaveLength(2);
           expect(result.answeredQuestions).toBe(6);
           expect(result.totalQuestions).toBe(6);
           expect(result.completionRate).toBe(100);
         });

         it('returns 100% when all answers are level 3', () => {
           const categories: CategoryQuestionCount[] = [
             { categoryId: 'cat1', totalQuestions: 2 },
             { categoryId: 'cat2', totalQuestions: 2 },
           ];

           const answers: Answer[] = [
             createAnswer('q1', 'cat1', 3),
             createAnswer('q2', 'cat1', 3),
             createAnswer('q3', 'cat2', 3),
             createAnswer('q4', 'cat2', 3),
           ];

           const result = calculateOverallScore(answers, categories);

           expect(result.percentage).toBe(100);
           expect(result.trafficLight).toBe('green');
           expect(result.completionRate).toBe(100);
         });

         it('returns 0% when all answers are level 0', () => {
           const categories: CategoryQuestionCount[] = [
             { categoryId: 'cat1', totalQuestions: 2 },
             { categoryId: 'cat2', totalQuestions: 2 },
           ];

           const answers: Answer[] = [
             createAnswer('q1', 'cat1', 0),
             createAnswer('q2', 'cat1', 0),
             createAnswer('q3', 'cat2', 0),
             createAnswer('q4', 'cat2', 0),
           ];

           const result = calculateOverallScore(answers, categories);

           expect(result.percentage).toBe(0);
           expect(result.trafficLight).toBe('red');
         });

         it('handles partial completion with correct completion rate', () => {
           const categories: CategoryQuestionCount[] = [
             { categoryId: 'cat1', totalQuestions: 3 },
             { categoryId: 'cat2', totalQuestions: 3 },
           ];

           const answers: Answer[] = [
             // Only 2 of 3 answered in cat1
             createAnswer('q1', 'cat1', 3),
             createAnswer('q2', 'cat1', 3),
             // Only 1 of 3 answered in cat2
             createAnswer('q4', 'cat2', 1),
           ];
           // cat1: 100%, cat2: 33.3%
           // Overall: (100 + 33.3) / 2 = 66.7%
           // Completion: 3 answered / 6 total = 50%

           const result = calculateOverallScore(answers, categories);

           expect(result.percentage).toBe(66.7);
           expect(result.trafficLight).toBe('yellow');
           expect(result.answeredQuestions).toBe(3);
           expect(result.totalQuestions).toBe(6);
           expect(result.completionRate).toBe(50);
         });

         it('uses equal weighting across all categories', () => {
           // 3 categories: one at 100%, one at 50%, one at 0%
           // Equal weighting: (100 + 50 + 0) / 3 = 50%
           const categories: CategoryQuestionCount[] = [
             { categoryId: 'cat1', totalQuestions: 1 },
             { categoryId: 'cat2', totalQuestions: 2 },
             { categoryId: 'cat3', totalQuestions: 1 },
           ];

           const answers: Answer[] = [
             createAnswer('q1', 'cat1', 3),  // cat1: 100%
             createAnswer('q2', 'cat2', 0),  // cat2: (0+100)/2 = 50%
             createAnswer('q3', 'cat2', 3),
             createAnswer('q4', 'cat3', 0),  // cat3: 0%
           ];
           // Overall: (100 + 50 + 0) / 3 = 50%

           const result = calculateOverallScore(answers, categories);

           expect(result.percentage).toBe(50);
         });

         it('includes individual category scores in result', () => {
           const categories: CategoryQuestionCount[] = [
             { categoryId: 'risk-analysis', totalQuestions: 3 },
             { categoryId: 'incident-response', totalQuestions: 3 },
           ];

           const answers: Answer[] = [
             createAnswer('q1', 'risk-analysis', 3),
             createAnswer('q2', 'risk-analysis', 3),
             createAnswer('q3', 'risk-analysis', 3),
             createAnswer('q4', 'incident-response', 1),
             createAnswer('q5', 'incident-response', 1),
             createAnswer('q6', 'incident-response', 1),
           ];

           const result = calculateOverallScore(answers, categories);

           expect(result.categoryScores).toHaveLength(2);

           const riskScore = result.categoryScores.find(
             (cs) => cs.categoryId === 'risk-analysis'
           );
           expect(riskScore?.percentage).toBe(100);
           expect(riskScore?.trafficLight).toBe('green');

           const incidentScore = result.categoryScores.find(
             (cs) => cs.categoryId === 'incident-response'
           );
           expect(incidentScore?.percentage).toBe(33.3);
           expect(incidentScore?.trafficLight).toBe('red');
         });

         it('handles categories with no answers (0% each)', () => {
           const categories: CategoryQuestionCount[] = [
             { categoryId: 'cat1', totalQuestions: 3 },
             { categoryId: 'cat2', totalQuestions: 3 },
           ];

           // No answers at all
           const result = calculateOverallScore([], categories);

           expect(result.percentage).toBe(0);
           expect(result.trafficLight).toBe('red');
           expect(result.answeredQuestions).toBe(0);
           expect(result.totalQuestions).toBe(6);
           expect(result.completionRate).toBe(0);
           expect(result.categoryScores[0].percentage).toBe(0);
           expect(result.categoryScores[1].percentage).toBe(0);
         });

         it('realistic scenario: 10 NIS2 categories with mixed maturity', () => {
           // Simulates a real assessment with all 10 NIS2 categories
           const categories: CategoryQuestionCount[] = [
             { categoryId: 'risk-analysis', totalQuestions: 3 },
             { categoryId: 'incident-response', totalQuestions: 3 },
             { categoryId: 'business-continuity', totalQuestions: 3 },
             { categoryId: 'supply-chain', totalQuestions: 3 },
             { categoryId: 'secure-development', totalQuestions: 3 },
             { categoryId: 'effectiveness', totalQuestions: 3 },
             { categoryId: 'cyber-hygiene', totalQuestions: 3 },
             { categoryId: 'cryptography', totalQuestions: 3 },
             { categoryId: 'access-control', totalQuestions: 3 },
             { categoryId: 'mfa-communication', totalQuestions: 3 },
           ];

           const answers: Answer[] = [
             // risk-analysis: all level 2 → 66.7%
             createAnswer('ra1', 'risk-analysis', 2),
             createAnswer('ra2', 'risk-analysis', 2),
             createAnswer('ra3', 'risk-analysis', 2),
             // incident-response: all level 1 → 33.3%
             createAnswer('ir1', 'incident-response', 1),
             createAnswer('ir2', 'incident-response', 1),
             createAnswer('ir3', 'incident-response', 1),
             // business-continuity: all level 3 → 100%
             createAnswer('bc1', 'business-continuity', 3),
             createAnswer('bc2', 'business-continuity', 3),
             createAnswer('bc3', 'business-continuity', 3),
             // supply-chain: all level 0 → 0%
             createAnswer('sc1', 'supply-chain', 0),
             createAnswer('sc2', 'supply-chain', 0),
             createAnswer('sc3', 'supply-chain', 0),
             // secure-development: all level 2 → 66.7%
             createAnswer('sd1', 'secure-development', 2),
             createAnswer('sd2', 'secure-development', 2),
             createAnswer('sd3', 'secure-development', 2),
             // effectiveness: all level 1 → 33.3%
             createAnswer('ef1', 'effectiveness', 1),
             createAnswer('ef2', 'effectiveness', 1),
             createAnswer('ef3', 'effectiveness', 1),
             // cyber-hygiene: all level 3 → 100%
             createAnswer('ch1', 'cyber-hygiene', 3),
             createAnswer('ch2', 'cyber-hygiene', 3),
             createAnswer('ch3', 'cyber-hygiene', 3),
             // cryptography: all level 1 → 33.3%
             createAnswer('cr1', 'cryptography', 1),
             createAnswer('cr2', 'cryptography', 1),
             createAnswer('cr3', 'cryptography', 1),
             // access-control: all level 2 → 66.7%
             createAnswer('ac1', 'access-control', 2),
             createAnswer('ac2', 'access-control', 2),
             createAnswer('ac3', 'access-control', 2),
             // mfa-communication: all level 0 → 0%
             createAnswer('mf1', 'mfa-communication', 0),
             createAnswer('mf2', 'mfa-communication', 0),
             createAnswer('mf3', 'mfa-communication', 0),
           ];

           // Expected per-category:
           // 66.7 + 33.3 + 100 + 0 + 66.7 + 33.3 + 100 + 33.3 + 66.7 + 0 = 500.0
           // Overall: 500.0 / 10 = 50.0%

           const result = calculateOverallScore(answers, categories);

           expect(result.percentage).toBe(50);
           expect(result.trafficLight).toBe('yellow');
           expect(result.categoryScores).toHaveLength(10);
           expect(result.answeredQuestions).toBe(30);
           expect(result.totalQuestions).toBe(30);
           expect(result.completionRate).toBe(100);

           // Verify individual traffic lights
           const getScore = (id: string) =>
             result.categoryScores.find((cs) => cs.categoryId === id);

           expect(getScore('business-continuity')?.trafficLight).toBe('green');
           expect(getScore('cyber-hygiene')?.trafficLight).toBe('green');
           expect(getScore('risk-analysis')?.trafficLight).toBe('yellow');
           expect(getScore('supply-chain')?.trafficLight).toBe('red');
           expect(getScore('mfa-communication')?.trafficLight).toBe('red');
         });
       });
       ```

    2. Run the tests to verify all pass:

       ```bash
       npx vitest run
       ```

       ALL tests must pass. If any test fails, fix the engine implementation (NOT the tests) — the tests encode the correct behavior specified in the research.

    3. Verify TypeScript compilation:

       ```bash
       npx tsc --noEmit
       ```

       Must return zero errors.

  </action>
  <verify>
    - `npx vitest run` passes ALL tests with 0 failures
    - `npx tsc --noEmit` returns zero errors
    - Test file contains at least 25 individual test cases (it() blocks)
    - Tests cover: maturityLevelToPercentage, roundToOneDecimal, getTrafficLight, calculateCategoryScore, calculateOverallScore
    - Tests include: boundary values (39.9, 40, 69.9, 70), empty arrays, mixed levels, category filtering, partial completion, floating-point precision, realistic 10-category scenario
  </verify>
  <done>
    All 25+ unit tests pass. Scoring engine correctly calculates per-category percentages, traffic lights, and overall scores. Boundary values, edge cases, and realistic 10-category scenarios verified. Zero TypeScript errors.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` passes ALL tests with 0 failures
2. `npx tsc --noEmit` returns zero TypeScript errors
3. `src/lib/scoring/engine.ts` exports 5 pure functions: maturityLevelToPercentage, roundToOneDecimal, getTrafficLight, calculateCategoryScore, calculateOverallScore
4. No React imports, no fetch calls, no global state — all functions are pure
5. `src/lib/scoring/methodology.ts` exports SCORING_METHODOLOGY with translation keys for UI display
6. Traffic light thresholds: <40% red, 40-69% yellow, >=70% green
7. Overall score uses equal weighting across all category scores
8. Floating-point precision handled: level 3 gives exactly 100%, not 99.9%
</verification>

<success_criteria>
- vitest installed and `npx vitest run` passes all tests
- Pure scoring functions calculate correct per-category percentages from maturity level answers
- Traffic light function returns correct colors for all boundary values
- Overall readiness score correctly averages all category scores with equal weighting
- Methodology data provides structured explanation for UI transparency
- TypeScript compiles with zero errors
- No React dependencies in any scoring file
</success_criteria>

<output>
After completion, create `.planning/phases/02-nis2-content-scoring-engine/02-03-SUMMARY.md`
</output>
