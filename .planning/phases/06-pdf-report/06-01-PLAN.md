---
phase: 06-pdf-report
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/pdf/fonts.ts
  - src/lib/pdf/styles.ts
  - src/lib/pdf/types.ts
  - src/components/pdf/PDFDocument.tsx
  - pages/api/pdf/download.ts
  - src/app/[locale]/results/components/download-pdf-button.tsx
  - src/app/[locale]/results/page.tsx
  - public/fonts/Inter-Regular.ttf
  - public/fonts/Inter-Bold.ttf
autonomous: true

must_haves:
  truths:
    - "User clicks download button on results page and receives a PDF file"
    - "PDF renders with Inter font and German Umlaute display correctly"
    - "API route responds within 10 seconds with application/pdf content"
    - "Download button shows loading state during PDF generation"
  artifacts:
    - path: "pages/api/pdf/download.ts"
      provides: "Pages Router API endpoint for PDF generation"
      exports: ["default"]
    - path: "src/lib/pdf/fonts.ts"
      provides: "Inter font registration at module load"
      contains: "Font.register"
    - path: "src/lib/pdf/styles.ts"
      provides: "PDF StyleSheet definitions"
      contains: "StyleSheet.create"
    - path: "src/lib/pdf/types.ts"
      provides: "TypeScript interfaces for PDF data payload"
      exports: ["PDFPayload", "PDFCompanyProfile", "PDFCategoryResult"]
    - path: "src/components/pdf/PDFDocument.tsx"
      provides: "Root PDF Document component with page structure"
      contains: "Document"
    - path: "src/app/[locale]/results/components/download-pdf-button.tsx"
      provides: "Client-side download button with loading state"
      contains: "fetch.*api/pdf/download"
  key_links:
    - from: "src/app/[locale]/results/components/download-pdf-button.tsx"
      to: "pages/api/pdf/download.ts"
      via: "POST fetch to /api/pdf/download"
      pattern: "fetch.*api/pdf/download.*POST"
    - from: "pages/api/pdf/download.ts"
      to: "src/components/pdf/PDFDocument.tsx"
      via: "renderToBuffer(<PDFDocument />)"
      pattern: "renderToBuffer"
    - from: "pages/api/pdf/download.ts"
      to: "src/lib/pdf/fonts.ts"
      via: "side-effect import for font registration"
      pattern: "import.*fonts"
    - from: "src/app/[locale]/results/page.tsx"
      to: "src/app/[locale]/results/components/download-pdf-button.tsx"
      via: "component import replacing disabled button"
      pattern: "DownloadPdfButton"
---

<objective>
Set up the PDF generation infrastructure: install dependencies, register Inter font for German Umlaute, create the Pages Router API endpoint with renderToBuffer, build the root PDF Document component skeleton, and wire the download button on the results page.

Purpose: This plan establishes the complete end-to-end PDF pipeline so that clicking "PDF herunterladen" produces a real (skeleton) PDF. Plan 02 fills in the content components.

Output: Working PDF download flow -- button click triggers API call, API renders PDF with Inter font, browser downloads file. PDF has placeholder pages that Plan 02 will replace with real content.
</objective>

<execution_context>
@C:\Users\mjoan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\mjoan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-pdf-report/06-RESEARCH.md

Key source files to reference:
@src/lib/nis2/types.ts
@src/lib/scoring/engine.ts
@src/stores/wizard-store.ts
@src/stores/gap-analysis-store.ts
@src/app/[locale]/results/page.tsx
@src/lib/nis2/categories.ts
@src/lib/nis2/recommendations.ts
@src/messages/de.json
@next.config.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, register fonts, create PDF types and styles</name>
  <files>
    package.json
    public/fonts/Inter-Regular.ttf
    public/fonts/Inter-Bold.ttf
    src/lib/pdf/fonts.ts
    src/lib/pdf/styles.ts
    src/lib/pdf/types.ts
  </files>
  <action>
1. Install PDF dependencies:
   ```
   npm install @react-pdf/renderer @ag-media/react-pdf-table
   ```
   Note: next.config.ts already has `serverExternalPackages: ['@react-pdf/renderer']` -- no config change needed.

2. Download Inter font TTF files to public/fonts/:
   - Inter-Regular.ttf (weight 400) from Google Fonts static TTF
   - Inter-Bold.ttf (weight 700) from Google Fonts static TTF
   Use curl to download from: https://github.com/rsms/inter/releases -- get the static TTF files (NOT variable font). Alternatively download from Google Fonts CDN. The files MUST be static TTF format (not variable OTF) because @react-pdf/renderer only supports TTF/WOFF.
   If direct download is problematic, use the Google Fonts Helper URLs from the research:
   - Regular: `https://fonts.gstatic.com/s/inter/v13/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hiA.woff2`
   - Bold: `https://fonts.gstatic.com/s/inter/v13/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuGKYAZ9hiA.woff2`
   IMPORTANT: If using woff2 URLs, reference them directly in fonts.ts via URL instead of local files. Local TTF files are preferred for Vercel cold-start performance. Try downloading from https://github.com/rsms/inter/releases/download/v4.1/Inter-4.1.zip -- extract Inter-Regular.ttf and Inter-Bold.ttf from the `extras/ttf/` folder.

3. Create `src/lib/pdf/fonts.ts`:
   ```typescript
   import { Font } from '@react-pdf/renderer';

   // Register Inter font at module load (not inside components)
   // Using local TTF files for Vercel cold-start performance
   // If local files unavailable, fall back to Google Fonts CDN URLs
   Font.register({
     family: 'Inter',
     fonts: [
       { src: '/fonts/Inter-Regular.ttf', fontWeight: 400 },
       { src: '/fonts/Inter-Bold.ttf', fontWeight: 700 },
     ],
   });

   // Disable hyphenation for German text (prevents incorrect word breaks)
   Font.registerHyphenationCallback((word: string) => [word]);
   ```
   IMPORTANT: If local TTF download fails, use the Google Fonts CDN woff2 URLs directly in the `src` field instead. The woff2 format also works with @react-pdf/renderer. Adjust based on what actually downloads successfully.

4. Create `src/lib/pdf/types.ts` -- TypeScript interfaces for the POST payload sent from client to API:
   ```typescript
   import type { TrafficLight, EffortLevel } from '@/lib/nis2/types';

   export interface PDFCompanyProfile {
     sectorName: string;        // Translated sector name
     subsectorName?: string;    // Translated subsector name (if any)
     employees: number;
     annualRevenue: number;
     classification: string;    // Translated: "Besonders wichtige Einrichtung" etc.
     classificationCategory: 'besonders-wichtig' | 'wichtig' | 'nicht-betroffen';
     legalReference: string;    // e.g., "par. 28 Abs. 1 Nr. 2 BSIG"
   }

   export interface PDFCategoryResult {
     categoryId: string;
     categoryName: string;      // Translated full name
     shortName: string;         // Translated short name
     percentage: number;
     trafficLight: TrafficLight;
     euArticle: string;         // e.g., "Art. 21(2)(a)"
     bsigParagraph: string;     // e.g., "par. 30 Abs. 2 Nr. 1 BSIG"
     verdict: string;           // Translated verdict text
   }

   export interface PDFRecommendation {
     categoryName: string;
     title: string;             // Translated
     description: string;       // Translated
     firstStep: string;         // Translated
     priority: 'high' | 'medium' | 'low';
     effortLevel: EffortLevel;
     legalReference: string;    // Always German original
     bsiReference: string;      // Always German original
   }

   export interface PDFMessages {
     [key: string]: string;     // Flattened translation keys for PDF
   }

   export interface PDFPayload {
     locale: 'de' | 'en';
     company: PDFCompanyProfile;
     overallScore: {
       percentage: number;
       trafficLight: TrafficLight;
       completionRate: number;
       answeredQuestions: number;
       totalQuestions: number;
     };
     categories: PDFCategoryResult[];
     recommendations: PDFRecommendation[];
     messages: PDFMessages;
   }
   ```

5. Create `src/lib/pdf/styles.ts` -- shared PDF StyleSheet:
   ```typescript
   import { StyleSheet } from '@react-pdf/renderer';

   // Color constants matching the web UI
   export const COLORS = {
     primary: '#1e40af',        // Blue-800
     primaryLight: '#dbeafe',   // Blue-100
     red: '#dc2626',
     redBg: '#fef2f2',
     yellow: '#ca8a04',
     yellowBg: '#fefce8',
     green: '#16a34a',
     greenBg: '#f0fdf4',
     gray50: '#f9fafb',
     gray100: '#f3f4f6',
     gray200: '#e5e7eb',
     gray300: '#d1d5db',
     gray500: '#6b7280',
     gray700: '#374151',
     gray900: '#111827',
     white: '#ffffff',
   } as const;

   export const TRAFFIC_LIGHT_COLORS: Record<string, { bg: string; text: string; dot: string }> = {
     red: { bg: COLORS.redBg, text: COLORS.red, dot: COLORS.red },
     yellow: { bg: COLORS.yellowBg, text: COLORS.yellow, dot: COLORS.yellow },
     green: { bg: COLORS.greenBg, text: COLORS.green, dot: COLORS.green },
   };

   export const styles = StyleSheet.create({
     page: {
       fontFamily: 'Inter',
       fontSize: 10,
       padding: 40,
       color: COLORS.gray900,
     },
     // Header
     headerTitle: {
       fontSize: 22,
       fontWeight: 700,
       color: COLORS.primary,
       marginBottom: 4,
     },
     headerSubtitle: {
       fontSize: 11,
       color: COLORS.gray500,
       marginBottom: 20,
     },
     // Sections
     sectionTitle: {
       fontSize: 14,
       fontWeight: 700,
       color: COLORS.gray900,
       marginBottom: 8,
       marginTop: 16,
     },
     // Disclaimer
     disclaimerBox: {
       padding: 12,
       backgroundColor: COLORS.gray100,
       border: `1 solid ${COLORS.gray300}`,
       marginBottom: 16,
     },
     disclaimerText: {
       fontSize: 8,
       color: COLORS.gray700,
       lineHeight: 1.5,
     },
     // Metadata
     metadataText: {
       fontSize: 8,
       color: COLORS.gray500,
       marginBottom: 2,
     },
     // Footer
     footer: {
       position: 'absolute',
       bottom: 20,
       left: 40,
       right: 40,
       fontSize: 8,
       color: COLORS.gray500,
       flexDirection: 'row',
       justifyContent: 'space-between',
     },
     // Traffic light dot
     trafficLightDot: {
       width: 10,
       height: 10,
       borderRadius: 5,
     },
     // Score bar background
     scoreBarBg: {
       height: 8,
       backgroundColor: COLORS.gray200,
       borderRadius: 4,
       flex: 1,
     },
     // Bold text
     bold: {
       fontWeight: 700,
     },
   });
   ```
  </action>
  <verify>
    - `npm ls @react-pdf/renderer` shows 4.x installed
    - `npm ls @ag-media/react-pdf-table` shows installed
    - Files exist: src/lib/pdf/fonts.ts, src/lib/pdf/styles.ts, src/lib/pdf/types.ts
    - If local font files used: public/fonts/Inter-Regular.ttf and public/fonts/Inter-Bold.ttf exist and are > 100KB each
    - TypeScript compiles: `npx tsc --noEmit src/lib/pdf/types.ts` (no errors)
  </verify>
  <done>
    PDF dependencies installed, font files available (local or CDN), font registration module ready, shared styles and types defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Pages Router API endpoint, PDF Document skeleton, and download button</name>
  <files>
    pages/api/pdf/download.ts
    src/components/pdf/PDFDocument.tsx
    src/app/[locale]/results/components/download-pdf-button.tsx
    src/app/[locale]/results/page.tsx
  </files>
  <action>
1. Create `pages/api/pdf/download.ts` -- Pages Router API route (NOT App Router):
   This uses the Pages Router pattern because App Router Route Handlers have a documented "ba.Component is not a constructor" error with React 19 + @react-pdf/renderer. The `pages/` directory coexists with `app/` directory in Next.js.

   ```typescript
   // Side-effect import to register fonts before rendering
   import '@/lib/pdf/fonts';

   import { renderToBuffer } from '@react-pdf/renderer';
   import type { NextApiRequest, NextApiResponse } from 'next';
   import PDFDocument from '@/components/pdf/PDFDocument';
   import type { PDFPayload } from '@/lib/pdf/types';

   export default async function handler(
     req: NextApiRequest,
     res: NextApiResponse
   ) {
     if (req.method !== 'POST') {
       return res.status(405).json({ error: 'Method not allowed' });
     }

     try {
       const payload: PDFPayload = req.body;

       // Validate payload has required fields
       if (!payload.locale || !payload.company || !payload.categories) {
         return res.status(400).json({ error: 'Invalid payload' });
       }

       const buffer = await renderToBuffer(
         <PDFDocument payload={payload} />
       );

       const timestamp = new Date().toISOString().split('T')[0];
       const filename = `NIS2-Readiness-Report-${timestamp}.pdf`;

       res.setHeader('Content-Type', 'application/pdf');
       res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
       res.setHeader('Content-Length', buffer.length);
       res.send(buffer);
     } catch (error) {
       console.error('PDF generation error:', error);
       res.status(500).json({
         error: 'PDF generation failed',
         message: error instanceof Error ? error.message : 'Unknown error',
       });
     }
   }
   ```

   IMPORTANT: The `@/` path alias must resolve correctly in Pages Router. If it doesn't, use relative paths: `import '../../src/lib/pdf/fonts'` etc. Check tsconfig.json paths to confirm `@/*` maps to `src/*`.

2. Create `src/components/pdf/PDFDocument.tsx` -- Root PDF Document (skeleton with placeholder content, Plan 02 adds real sections):
   ```typescript
   import { Document, Page, Text, View } from '@react-pdf/renderer';
   import { styles, COLORS } from '@/lib/pdf/styles';
   import type { PDFPayload } from '@/lib/pdf/types';

   interface PDFDocumentProps {
     payload: PDFPayload;
   }

   const PDFDocument = ({ payload }: PDFDocumentProps) => {
     const { locale, company, overallScore, categories, recommendations, messages } = payload;
     const generatedDate = new Intl.DateTimeFormat(locale === 'de' ? 'de-DE' : 'en-GB', {
       dateStyle: 'long',
     }).format(new Date());

     return (
       <Document
         title={messages['pdf.title'] || 'NIS2 Readiness Report'}
         author="NIS2-Bereitschaftspruefung"
         subject="NIS2 Readiness Assessment Report"
       >
         {/* Page 1: Cover + Disclaimer + Company Profile */}
         <Page size="A4" style={styles.page}>
           <Text style={styles.headerTitle}>
             {messages['pdf.title'] || 'NIS2-Readiness-Report'}
           </Text>
           <Text style={styles.headerSubtitle}>
             {messages['pdf.subtitle'] || 'Ergebnis der NIS2-Bereitschaftspruefung'}
           </Text>

           {/* Disclaimer */}
           <View style={styles.disclaimerBox}>
             <Text style={styles.disclaimerText}>
               {messages['pdf.disclaimer'] || 'Ihre Angaben deuten darauf hin, dass der folgende Reifegrad vorliegt. Ein hoher Score bedeutet nicht automatisch NIS2-Konformitaet.'}
             </Text>
           </View>

           {/* Metadata */}
           <Text style={styles.metadataText}>
             Rechtsstand: Januar 2025 (NIS2-Richtlinie (EU) 2022/2555, NIS2UmsG)
           </Text>
           <Text style={styles.metadataText}>
             {messages['pdf.generatedAt'] || 'Erstellt am'}: {generatedDate}
           </Text>

           {/* Company Profile placeholder -- Plan 02 replaces */}
           <View style={{ marginTop: 20 }}>
             <Text style={styles.sectionTitle}>
               {messages['pdf.companyProfile'] || 'Unternehmensprofil'}
             </Text>
             <Text>{company.sectorName} - {company.classification}</Text>
             <Text>{messages['pdf.employees'] || 'Mitarbeiter'}: {company.employees}</Text>
           </View>

           {/* Overall Score placeholder */}
           <View style={{ marginTop: 20 }}>
             <Text style={styles.sectionTitle}>
               {messages['pdf.overallScore'] || 'Gesamter Reifegrad'}
             </Text>
             <Text style={{ fontSize: 24, fontWeight: 700, color: COLORS.primary }}>
               {overallScore.percentage}%
             </Text>
           </View>

           {/* Footer */}
           <View style={styles.footer} fixed>
             <Text>NIS2-Bereitschaftspruefung</Text>
             <Text render={({ pageNumber, totalPages }) => `${pageNumber} / ${totalPages}`} />
           </View>
         </Page>

         {/* Page 2: Categories placeholder -- Plan 02 replaces */}
         <Page size="A4" style={styles.page}>
           <Text style={styles.sectionTitle}>
             {messages['pdf.categories'] || 'Ergebnisse nach Kategorie'}
           </Text>
           {categories.map((cat) => (
             <View key={cat.categoryId} style={{ marginBottom: 8 }}>
               <Text>{cat.categoryName}: {cat.percentage}%</Text>
             </View>
           ))}
           <View style={styles.footer} fixed>
             <Text>NIS2-Bereitschaftspruefung</Text>
             <Text render={({ pageNumber, totalPages }) => `${pageNumber} / ${totalPages}`} />
           </View>
         </Page>

         {/* Page 3: Recommendations placeholder -- Plan 02 replaces */}
         <Page size="A4" style={styles.page}>
           <Text style={styles.sectionTitle}>
             {messages['pdf.recommendations'] || 'Handlungsempfehlungen'}
           </Text>
           {recommendations.slice(0, 10).map((rec, idx) => (
             <View key={idx} style={{ marginBottom: 6 }}>
               <Text style={styles.bold}>{rec.title}</Text>
               <Text style={{ fontSize: 9 }}>{rec.firstStep}</Text>
             </View>
           ))}
           <View style={styles.footer} fixed>
             <Text>NIS2-Bereitschaftspruefung</Text>
             <Text render={({ pageNumber, totalPages }) => `${pageNumber} / ${totalPages}`} />
           </View>
         </Page>
       </Document>
     );
   };

   export default PDFDocument;
   ```

3. Create `src/app/[locale]/results/components/download-pdf-button.tsx` -- Client component:
   This button collects all data from stores, flattens translations, and POSTs to the API.

   ```typescript
   'use client';

   import { useState } from 'react';
   import { Button } from '@/components/ui/button';
   import { Download, Loader2 } from 'lucide-react';
   import { useLocale, useTranslations } from 'next-intl';
   import { useWizardStore } from '@/stores/wizard-store';
   import { CATEGORIES } from '@/lib/nis2/categories';
   import { SECTORS } from '@/lib/nis2/sectors';
   import { getRecommendationsByCategory } from '@/lib/nis2/recommendations';
   import type { PDFPayload, PDFCategoryResult, PDFRecommendation, PDFCompanyProfile } from '@/lib/pdf/types';
   import type { CategoryScore, OverallScore } from '@/lib/nis2/types';

   interface DownloadPdfButtonProps {
     overallScore: OverallScore;
   }

   export function DownloadPdfButton({ overallScore }: DownloadPdfButtonProps) {
     const [isGenerating, setIsGenerating] = useState(false);
     const [error, setError] = useState<string | null>(null);
     const locale = useLocale() as 'de' | 'en';
     const t = useTranslations();
     const tResults = useTranslations('results');
     const tCategories = useTranslations('categories');
     const tRec = useTranslations('recommendations');
     const tClassification = useTranslations('classification');
     const tSectors = useTranslations('sectors');
     const tCheck = useTranslations('check');

     // Get wizard store data for company profile
     const formData = useWizardStore((state) => state.formData);

     const buildPayload = (): PDFPayload => {
       // Build company profile from wizard store
       const sector = SECTORS.find((s) => s.id === formData.sectorId);
       const sectorName = sector
         ? tSectors(`${sector.id}.name` as any)
         : formData.sectorId || '';
       const subsector = sector?.subsectors?.find((s) => s.id === formData.subsectorId);
       const subsectorName = subsector
         ? tSectors(`${sector!.id}.subsectors.${subsector.id}` as any)
         : undefined;

       // Determine classification text
       const classificationCategory = formData.isKritis
         ? 'besonders-wichtig' as const
         : 'besonders-wichtig' as const; // Will be overridden by actual store value
       // Use the classification from the check result step -- since we only store formData,
       // infer from overallScore presence that user completed the flow
       const classificationText = tCheck('resultStep.besondersWichtig');

       const company: PDFCompanyProfile = {
         sectorName,
         subsectorName,
         employees: formData.employees || 0,
         annualRevenue: formData.annualRevenue || 0,
         classification: classificationText,
         classificationCategory: 'besonders-wichtig', // Placeholder - needs store data
         legalReference: '',
       };

       // Build category results
       const categories: PDFCategoryResult[] = overallScore.categoryScores.map((catScore) => {
         const category = CATEGORIES.find((c) => c.id === catScore.categoryId)!;
         const categoryName = tCategories(category.nameKey.replace('categories.', '') + '.name' as any);
         const shortName = tCategories(category.shortNameKey.replace('categories.', '') + '.shortName' as any);
         const verdict = tResults(`verdict.${catScore.trafficLight}` as any);

         return {
           categoryId: catScore.categoryId,
           categoryName,
           shortName,
           percentage: catScore.percentage,
           trafficLight: catScore.trafficLight,
           euArticle: category.euArticle,
           bsigParagraph: category.bsigParagraph,
           verdict,
         };
       });

       // Build recommendations (sorted: red categories first, high priority first)
       const trafficLightOrder = { red: 0, yellow: 1, green: 2 };
       const priorityOrder = { high: 0, medium: 1, low: 2 };

       const recommendations: PDFRecommendation[] = overallScore.categoryScores
         .sort((a, b) => trafficLightOrder[a.trafficLight] - trafficLightOrder[b.trafficLight])
         .flatMap((catScore) => {
           const category = CATEGORIES.find((c) => c.id === catScore.categoryId)!;
           const categoryName = tCategories(category.nameKey.replace('categories.', '') + '.name' as any);
           const recs = getRecommendationsByCategory(catScore.categoryId);

           return recs
             .sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority])
             .map((rec) => ({
               categoryName,
               title: tRec(rec.titleKey.replace('recommendations.', '') + '.title' as any),
               description: tRec(rec.descriptionKey.replace('recommendations.', '') + '.description' as any),
               firstStep: tRec(rec.firstStepKey.replace('recommendations.', '') + '.firstStep' as any),
               priority: rec.priority,
               effortLevel: rec.effortLevel,
               legalReference: rec.legalReference,
               bsiReference: rec.bsiReference,
             }));
         });

       // Flatten translations needed by PDF components
       const messages: Record<string, string> = {
         'pdf.title': locale === 'de' ? 'NIS2-Readiness-Report' : 'NIS2 Readiness Report',
         'pdf.subtitle': locale === 'de'
           ? 'Ergebnis der NIS2-Bereitschaftsprüfung'
           : 'NIS2 Readiness Assessment Results',
         'pdf.disclaimer': tResults('disclaimer.text'),
         'pdf.companyProfile': locale === 'de' ? 'Unternehmensprofil' : 'Company Profile',
         'pdf.sector': locale === 'de' ? 'Sektor' : 'Sector',
         'pdf.subsector': locale === 'de' ? 'Teilsektor' : 'Subsector',
         'pdf.employees': locale === 'de' ? 'Mitarbeiter' : 'Employees',
         'pdf.revenue': locale === 'de' ? 'Jahresumsatz' : 'Annual Revenue',
         'pdf.classification': locale === 'de' ? 'NIS2-Einstufung' : 'NIS2 Classification',
         'pdf.legalBasis': locale === 'de' ? 'Rechtsgrundlage' : 'Legal Basis',
         'pdf.overallScore': locale === 'de' ? 'Gesamter Reifegrad' : 'Overall Readiness Score',
         'pdf.categories': locale === 'de' ? 'Ergebnisse nach Kategorie' : 'Results by Category',
         'pdf.recommendations': locale === 'de' ? 'Handlungsempfehlungen' : 'Recommendations',
         'pdf.quickWins': locale === 'de' ? 'Quick Wins' : 'Quick Wins',
         'pdf.generatedAt': locale === 'de' ? 'Erstellt am' : 'Generated on',
         'pdf.legalDate': locale === 'de' ? 'Stand der Rechtslage: Januar 2025' : 'Legal status: January 2025',
         'pdf.score': locale === 'de' ? 'Score' : 'Score',
         'pdf.status': locale === 'de' ? 'Status' : 'Status',
         'pdf.firstStep': locale === 'de' ? 'Nächster Schritt' : 'Next Step',
         'pdf.priority': locale === 'de' ? 'Priorität' : 'Priority',
         'pdf.priorityHigh': locale === 'de' ? 'Hoch' : 'High',
         'pdf.priorityMedium': locale === 'de' ? 'Mittel' : 'Medium',
         'pdf.priorityLow': locale === 'de' ? 'Niedrig' : 'Low',
         'pdf.effort': locale === 'de' ? 'Aufwand' : 'Effort',
         'pdf.effortQuick': locale === 'de' ? 'Schnell umsetzbar' : 'Quick to implement',
         'pdf.effortMedium': locale === 'de' ? 'Mittelfristig' : 'Medium-term',
         'pdf.effortStrategic': locale === 'de' ? 'Strategisch' : 'Strategic',
         'pdf.legalRef': locale === 'de' ? 'Rechtsgrundlage' : 'Legal Reference',
         'pdf.bsiRef': locale === 'de' ? 'BSI-Grundschutz' : 'BSI IT-Grundschutz',
         'pdf.legalRefNote': 'Original German text as per legal requirements',
         'pdf.trafficLight.red': locale === 'de' ? 'Handlungsbedarf' : 'Action Required',
         'pdf.trafficLight.yellow': locale === 'de' ? 'Verbesserung nötig' : 'Improvement Needed',
         'pdf.trafficLight.green': locale === 'de' ? 'Gut umgesetzt' : 'Well Implemented',
         'pdf.completionRate': locale === 'de'
           ? `${overallScore.answeredQuestions} von ${overallScore.totalQuestions} Fragen beantwortet`
           : `${overallScore.answeredQuestions} of ${overallScore.totalQuestions} questions answered`,
       };

       return {
         locale,
         company,
         overallScore: {
           percentage: overallScore.percentage,
           trafficLight: overallScore.trafficLight,
           completionRate: overallScore.completionRate,
           answeredQuestions: overallScore.answeredQuestions,
           totalQuestions: overallScore.totalQuestions,
         },
         categories,
         recommendations,
         messages,
       };
     };

     const handleDownload = async () => {
       setIsGenerating(true);
       setError(null);

       try {
         const payload = buildPayload();

         const response = await fetch('/api/pdf/download', {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify(payload),
         });

         if (!response.ok) {
           const errorData = await response.json().catch(() => ({}));
           throw new Error(errorData.message || 'PDF generation failed');
         }

         const blob = await response.blob();
         const url = window.URL.createObjectURL(blob);
         const a = document.createElement('a');
         a.href = url;
         a.download = `NIS2-Readiness-Report-${new Date().toISOString().split('T')[0]}.pdf`;
         document.body.appendChild(a);
         a.click();
         window.URL.revokeObjectURL(url);
         document.body.removeChild(a);
       } catch (err) {
         console.error('PDF download failed:', err);
         setError(err instanceof Error ? err.message : 'Download failed');
       } finally {
         setIsGenerating(false);
       }
     };

     return (
       <div className="flex flex-col items-center gap-2">
         <Button
           variant="default"
           onClick={handleDownload}
           disabled={isGenerating}
         >
           {isGenerating ? (
             <Loader2 className="mr-2 h-4 w-4 animate-spin" />
           ) : (
             <Download className="mr-2 h-4 w-4" />
           )}
           {isGenerating
             ? (locale === 'de' ? 'PDF wird erstellt...' : 'Generating PDF...')
             : tResults('actions.downloadPdf')}
         </Button>
         {error && (
           <p className="text-sm text-destructive">{error}</p>
         )}
       </div>
     );
   }
   ```

   IMPORTANT NOTES on the download button:
   - The translation key lookups (e.g., `category.nameKey.replace('categories.', '') + '.name'`) must match how the results page currently resolves them. Check the results page.tsx pattern: it uses `tCategories(cat.category.nameKey.replace('categories.', ''))` -- meaning nameKey is `categories.riskAnalysis.name` and after replace it becomes `riskAnalysis.name`. The tCategories hook scopes to `categories` namespace, so `tCategories('riskAnalysis.name')` resolves to `de.json > categories > riskAnalysis > name`. Replicate this EXACT pattern.
   - Similarly for recommendations: `rec.titleKey` is `recommendations.ra1.title`, `tRec(rec.titleKey.replace('recommendations.', ''))` becomes `tRec('ra1.title')` which resolves `de.json > recommendations > ra1 > title`. But the tRec hook is scoped to `recommendations`, so nested keys need dot notation. Check: `tRec('ra1.title')` should work with nested JSON `{ "ra1": { "title": "..." } }`. Verify this matches the actual i18n key structure.
   - The classification data is incomplete in the wizard store (it only stores formData, not the computed classification result). For Plan 01, use what's available. Plan 02 may need to refine this by either storing classification in the wizard store or re-computing it client-side.

4. Update `src/app/[locale]/results/page.tsx`:
   - Import `DownloadPdfButton` from `./components/download-pdf-button`
   - Replace the disabled PDF button (currently `<Button variant="default" disabled className="opacity-50">`) with `<DownloadPdfButton overallScore={overallScore} />`
   - Keep the retake button as-is
   - Remove the "(Verfuegbar in Kuerze)" label since PDF is now functional
  </action>
  <verify>
    1. Run `npm run build` -- should compile without errors (Pages Router and App Router coexist)
    2. Run `npm run dev`, navigate to results page (need completed gap analysis with 30 answers in localStorage)
    3. Click "PDF herunterladen" button
    4. Verify: loading spinner appears, PDF downloads, file opens in PDF viewer
    5. Verify: German Umlaute (ae, oe, ue, ss) render correctly in the PDF
    6. Verify: PDF has 3 pages (cover, categories, recommendations)
    7. Check browser DevTools Network tab: POST to /api/pdf/download returns 200 with content-type application/pdf
  </verify>
  <done>
    End-to-end PDF download works: button click on results page sends POST to Pages Router API, API renders PDF with Inter font via renderToBuffer, browser downloads the file. PDF skeleton has cover page with disclaimer + metadata, categories list, and recommendations list. German Umlaute render correctly.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm run dev` -- results page shows functional "PDF herunterladen" button (not disabled)
3. Clicking button triggers PDF generation and download
4. Downloaded PDF:
   - Opens in any PDF viewer without corruption
   - Shows Inter font (not system default)
   - German Umlaute (ae, oe, ue, ss) display correctly
   - Has 3 pages with placeholder content
   - Shows disclaimer on first page
   - Shows Rechtsstand-Datum and Erstellungsdatum
   - Has page numbers in footer
5. API endpoint returns 405 for GET requests, 400 for invalid payloads
</verification>

<success_criteria>
- PDF download works end-to-end from results page button click to file in Downloads folder
- Inter font registered and rendering German Umlaute correctly
- Pages Router API endpoint at /api/pdf/download responds with PDF buffer
- Download button shows loading state during generation
- PDF contains skeleton content (cover, categories, recommendations) on 3 pages
- Build (`npm run build`) passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-pdf-report/06-01-SUMMARY.md`
</output>
